자바 == OOP(Object Oriented Programming)

<객체지향의 특징> 

1. 캡슐화 : 클래스에 필드와 메소드를 묶어주는 것
   - 정보은닉
   - 모듈성

2. 상속 ★
   - 부모가 갖는 자원(필드,메소드)을 아낌없이 물려주는 것.  
   - 관련키워드 extends
   - 단일상속이 기본원칙.

3. 다형성 
  - 메소드 오버라이딩(MethodOverriding) ★★ 
  - 메소드 오버로딩(MethodOverloading)



<객체지향의 특징> 

1. 캡슐화 : 클래스에 필드와 메소드를 묶어주는 것
   - 정보은닉
   - 모듈성

class A{

    void hello( ){

    }
}
======================
    My m = new My();
      m.감기약( );
======================


class My{

    public 감기약(){
          기침_sol();
          열_sol();
          가_sol();
    }

    private 기침_sol(){
    }

    private 열_sol(){

     }

    private 가_sol(){

    }

}



2. 상속 ★
   - 부모가 갖는 자원(필드,메소드)을 아낌없이 물려주는 것.  
   - 관련키워드 extends
    - 단일상속이 기본원칙.

   API문서(Application Programming Interface)
     ==> 

     java.lang.Object                          상위, super, 부모클래스   
         |
         +--  java.lang.String                 하위, sub, 자식클래스  

   ※ Object클래스 ---> 최상위클래스!!
                        ---> 자바의 모든 클래스의 부모클래스
	            ---> 사용자가 정의하는 클래스에도 자동 추가 extends Object


3. 다형성 
  - 메소드 오버라이딩(MethodOverriding) ★★  ==> 메소드 재정의
      :상속에서 나온 개념
      :부모가 갖는 메소드를 자식클래스에서 재정의

  - 메소드 오버로딩(MethodOverloading)
      :한 클래스내에 동일한 메소드를 여러개 구현
       (단, 인자의 갯수가 다르거나 자료형이 달라야 한다)


class A{

  void hello(){
    System.out.println("안녕~!!");
  }

  void hello(String name){ //---> 오버로딩 메소드
    System.out.println("안녕,"+name+"!!");
  }

}
//인자 갯수가 다르므로 오버로딩
=============================================================
<생성자> Constructor
 - 새로운 객체를 생성하기 위해서 초기화해주는 메소드.

1. 생성자의 이름은 반드시 클래스명과 일치(대소문자 일치)
2. 리턴자료형을 명시하지 않는다. (void조차 X)

//public class SpeedTest{
	SpeedTest(){
	}
}
//() 비어있으면 기본생성자라고 한다

------ 1,2번 : 일반 메소드와의 차이점-------------
3. 객체생성시 자동으로 호출.
4. 클래스내에 생성자가 하나도 없다면
   자바컴파일러가 컴파일시 자동으로 (기본생성자를) 추가.

※ 주의) 만약, 클래스내에 한개 이상의 생성자가 정의 되어 있다면
             컴파일러는 소드코드에 관여하지 않는다!!

class Abc{
  int su;
  My  my;

  Abc( ){//기본생성자(매개변수 비어있는 생성자)---> 초기화(값할당) 메소드   //( ) 값 X, 기본생성자
     //멤버필드에 대한 초기화 작업
     su = 10;
     my = new My();

     //(일반메소드 호출 전 1번 실행하는)선행작업

  }//생성자

  Abc(String name){//오버로딩 생성자   //( ) 값 O, 오버로딩생성자
  
  }

  ABc(int age){
    //--->컴파일 에러발생: 클래스명과 일치하지 않으므로 일반메소드!!
    //---> 리턴자료형을 명시하지 않았음!!
  }
  
  void hello(){  
  }
}//class Abc
=========================================================================
<this> 자기참조 연산자
  ===> 현재클래스를 가르키는 레퍼런스 변수(참조변수)!!
  ===> 보통은 생략함

1. 메소드 내에서 사용.
2. 객체 생성자내에서 다른 생성자를 호출시 사용.
3. 매개변수(지역변수)와 멤버변수(필드)를 구분하기 위해
   멤버변수 앞에 this.을 붙여 사용.
   
형식)
    this.필드명
    this.메소드명();
    this( ); //생성자 호출
참고)    
    super.필드명
    super.메소드명();
    super( ); //부모클래스 생성자 호출
========================================================================
   Abc a = new Abc(  );
               -------
	       기본생성자 호출!!
      a.hello();


   Abc a2 = new Abc("길동");
               ------------
	       오버로딩생성자 호출!!
      a2.hello();

=========================================================================

<접근지정(제한)자> : AccessControl   
   public         - 서로 다른 패키지에서도 접근가능
   protected      - 서로 같은 패키지에서 접근가능
   				  + 만약 상속관계를 갖는다면 다른 패키지라도 자식이 부모를 참조!!
   default(생략)   - 서로 같은 패키지에서 접근가능
   private        - 같은 클래스 내에서만 (멤버끼리만) 접근가능

==> 접근지정자 위치
  1. 필드
   [접근지정자4개] 자료형 변수명;
  2. 메소드  
   [접근지정자4개] 리턴자료형 메소드명(  )
   {
     
   }
  3. 클래스
   [접근지정자2개-public/default] class 클래스명{
    
    }